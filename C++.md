* 内存分配
  >1. 栈区（stack）  
  由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈.  
  > 2. 堆区（heap）  
    一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表  
  >3. 全局区（静态区）（static）  
    全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域,未初始化的全局变量和未初始化的静态变量在相邻的另一块区域. 程序结束后由系统释放 
  >4. 文字常量区  
   常量字符串就是放在这里的。 程序结束后由系统释放  
  >5. 程序代码区  
   存放函数体的二进制代码  
* 内存泄漏  
  >程序执行时开辟了堆上的空间,但使用完毕后没有释放该空间  
* 野指针  
  >指向非法内存块的指针
* 函数指针与数组指针  
  >* int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量.  
  >* int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10.  
  >* int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的.  
  >* int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的.  
* volatile
  >1. volatile修饰变量  
   volatile的本意是“易变的”遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问.  
   当使用volatile声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据.  
  >2. volatile修饰成员函数  
   若类的对象被声明为volatile,则只能调用volatile成员函数
* static
  >1. static修饰函数内变量  
   static修饰的变量分配在静态存储区，在程序整个运行期间都不释放  
   static局部变量在初次运行时进行初始化工作，且只初始化一次  
  >2. static修饰函数外变量/函数  
   用来表示不能被其它文件访问的全局变量和函数.  
  >3. static修饰数据成员  
   静态数据成员实际上是类域中的全局变量,这种数据成员的生存期大于类的对象  
   静态数据成员每个类有一份,普通数据成员每个对象有一份  
  >4. static修饰成员函数  
   静态成员函数不可以调用类的非静态成员  
   静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问  
* const
  >1. const修饰普通变量和指针  
   const修饰的类型为TYPE的变量value是不可变的  
   const TYPE value;  
   TYPE const value;  
   指针本身是常量  
   char* const pContent;  
   指针所指向的内容是常量不可变  
   const char *pContent;  
   char const *pContent;  
   两者都不可变  
   const char* const pContent;  
  >2. const修饰类对象  
   任何成员都不能被修改,只能调用const成员函数
  >3. const修饰数据成员  
   const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的不同的对象其const数据成员的值可以不同  
  >4. const修饰成员函数  
   用const修饰的成员函数不能改变对象的成员变量  
  >5. const常量与define宏定义的区别  
  >* 编译器处理方式不同  
   define宏是在预处理阶段展开.  
   const常量是编译运行阶段使用.  
  >* 类型和安全检查不同  
   define宏没有类型，不做任何类型检查，仅仅是展开.  
   const常量有具体的类型，在编译阶段会执行类型检查.  
  >* 存储方式不同  
   define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存  
   const常量会在内存中分配(可以是堆中也可以是栈中)  
* mutable
  > mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词,在C++中，mutable也是为了突破const的限制而设置的.  
  > 被mutable修饰的变量(mutable只能用于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中.  
* extern  
  >1. extern修饰变量或函数  
   表明此变量/函数是在别的文件定义的，要在此处引用
  >2. extern "C" {}  
   表明之后的代码段为C语言代码段,告诉链接器在链接的时候用C函数规范来链接.   
   主要原因是C++和C程序编译完成后再目标代码中命名规则不同  
* strlen和sizeof区别
  >* sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数.  
  >* sizeof参数可以是任何数据的类型或者数据（sizeof数组参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串.  
  >* 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小.  
  >* sizeof()返回字节个数,strlen()返回字符串长度(不含'/0')  
* malloc和sizeof区别
  >
