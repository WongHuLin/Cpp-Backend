## 语言基础
* 内存分配
  >* 栈区（stack）  
  由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  
  >* 堆区（heap）  
    一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表  
  >* 全局区（静态区）（static）  
    全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束后由系统释放 
  >* 文字常量区  
   常量字符串就是放在这里的。 程序结束后由系统释放  
  >* 程序代码区  
   存放函数体的二进制代码  
* 内存泄漏  
  >程序执行时开辟了堆上的空间，但使用完毕后没有释放该空间  
* 野指针  
  >指向非法内存块的指针
* 函数指针与数组指针  
  >* int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。  
  >* int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。  
  >* int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。  
  >* int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。  
* 迭代器失效
  >当迭代器指向的元素位置发生改变的时候迭代器失效。  
  >* 数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，插入点和删除点之后的迭代器全部失效。特别的对于vector，当insert操作导致容器扩容时，所有的迭代器均失效。  
  >* 链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，insert操作不会使得任何迭代器失效，erase操作使指向删除位置的迭代器失效，但是不会失效其他迭代器。  
  >* 树形数据结构：使用红黑树来存储数据，insert操作不会使得任何迭代器失效，erase操作使指向删除位置的迭代器失效，但是不会失效其他迭代器。  
* volatile
  >* volatile修饰变量  
   volatile的本意是“易变的”遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。当使用volatile声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。  
  >* volatile修饰成员函数  
   若类的对象被声明为volatile，则只能调用volatile成员函数
* static
  >* static修饰函数内变量  
   static修饰的变量分配在静态存储区，在程序整个运行期间都不释放  
   static局部变量在初次运行时进行初始化工作，且只初始化一次  
  >* static修饰函数外变量/函数  
   用来表示不能被其它文件访问的全局变量和函数。  
  >* static修饰数据成员  
   静态数据成员实际上是类域中的全局变量，这种数据成员的生存期大于类的对象  
   静态数据成员每个类有一份，普通数据成员每个对象有一份  
  >* static修饰成员函数  
   静态成员函数不可以调用类的非静态成员  
   静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问  
* const
  >* const修饰普通变量和指针  
   const修饰的类型为TYPE的变量value是不可变的  
   const TYPE value;  
   TYPE const value;  
   指针本身是常量  
   char* const pContent;  
   指针所指向的内容是常量不可变  
   const char *pContent;  
   char const *pContent;  
   两者都不可变  
   const char* const pContent;  
  >* const修饰类对象  
   任何成员都不能被修改，只能调用const成员函数
  >* const修饰数据成员  
   const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的不同的对象其const数据成员的值可以不同  
  >* const修饰成员函数  
   用const修饰的成员函数不能改变对象的成员变量  
  >* const常量与define宏定义的区别  
  >* 编译器处理方式不同  
   define宏是在预处理阶段展开。  
   const常量是编译运行阶段使用。  
  >* 类型和安全检查不同  
   define宏没有类型，不做任何类型检查，仅仅是展开。  
   const常量有具体的类型，在编译阶段会执行类型检查。  
  >* 存储方式不同  
   define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存  
   const常量会在内存中分配(可以是堆中也可以是栈中)  
* mutable
  > mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词，在C++中，mutable也是为了突破const的限制而设置的。  
  > 被mutable修饰的变量(mutable只能用于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。  
* extern  
  >* extern修饰变量或函数  
   表明此变量/函数是在别的文件定义的，要在此处引用
  >* extern "C" {}  
   表明之后的代码段为C语言代码段，告诉链接器在链接的时候用C函数规范来链接。   
   主要原因是C++和C程序编译完成后再目标代码中命名规则不同  
* strlen和sizeof区别
  >* sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。  
  >* sizeof参数可以是任何数据的类型或者数据（sizeof数组参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。  
  >* 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。  
  >* sizeof()返回字节个数，strlen()返回字符串长度(不含'/0')  
* malloc和new区别
  >* new 返回指定类型的指针，并且可以自动计算所需要大小。而 malloc 则必须要由我们计算字节数，并且在返回后强行转换为实际类型的指针。  
  >* malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能。new和delete除了分配回收功能外，还会调用构造函数和析构函数。  
  >* 如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。 
* 内联函数  
  >* 当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处。  
  >* inline对编译器而言只是一个建议，编译器优化时可能会自动忽略掉内联。  
  >* 优点:没有函数压栈出栈的开销。与宏相比，宏为简单的文本替换，有时候执行结果与预料结果可能不同 SQUARE(1+2)。  
  >* 缺点:代码量膨胀，导致内存中代码区体积变大，从而影响程序性能。  
## 面向对象基础
* 面向对象的三大特性  
  >* 封装性：隐藏实现细节，使得代码模块化；封装是把函数和数据捆绑起来，对数据的访问只能通过已定义的接口。  
  >* 继承性：让某种类获得另一个类的数据和函数。  
  >* 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。  
## C++11
* RAII  
  >RAII（Resource Acquisition Is Initialization）,是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的技术。RAII 的一般做法是：在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。  
* 右值引用
  >右值引用(R-value reference)，标记为T &&，说到右值引用类型之前先要了解什么是左值和右值。左值有名称，对应指定内存域，可访问；右值不具名，不对应内存域，不可访问。临时对像是右值。左值可处于等号左边，右值只能放在等号右边。区分表达式的左右值属性有一个简便方法：若可对表达式用 & 符取址，则为左值，否则为右值。右值引用本身为左值。  
* 引用折叠  
  >* 所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&）  
  >* 所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）  
* std::move  
  >std::move()函数可以理解为一个右值引用转换，即获取实参的右值引用，实现方式如下：  
  >```
  >template <typename T>  
  >typename remove_reference<T>::type&& move(T&& t)
  >{
  >     return static_cast<typename remove_reference<T>::type&&>(t);
  >}
  >```
* 移动构造函数与移动赋值运算符
  >```
  >class A
  >{
  >     A(A&& obj);
  >     A&operator=(A&& obj);
  >};
  >```
  >由于函数实参为一个右值引用，我们认为它具有临时性，所以我们进行浅拷贝（对于该对象堆上的资源，我们只拷贝它的地址，而不完全开辟新的内存空间拷贝它的资源），浅拷贝完成后将函数实参对象内的指针变量置为nullptr。所以，对被浅拷贝过的对象进行操作是未定义的行为。  
* 函数对象
  >函数对象即一个可执行的对象，通常做法是在重载一个类的()运算符。函数对象可用来代替函数指针。
* lambda表达式
  >[ *捕获列表* ] ( *参数列表* ) -> *返回类型* { *函数体* }  
  >lambda是函数对象，lambda产生的类为捕获的参数创建相应的数据成员  
* std::function
  >std::function< *返回类型* ( *参数列表* ) >是一个通用函数封装模板，可以封装所有的可调用元素，例如普通函数和函数对象函数指针  
* std::bind
  >std::bind用来为函数对象绑定参数，接受一个函数对象与数个待绑定的参数返回一个新的函数对象，用占位符（std::placeholders::)表示新生成的函数对象的参数。
  >```
  >int fun(int,int);
  >std::function<int(int)> new_fun = std::bind(fun,1,std::placeholders::_1);
  >```
* 智能指针
  >以RAII的方式管理资源  
  >* 引用计数:  
  >要想实现引用计数这个功能，需要在类内定义一个指针成员，指针成员指向在堆上存储的引用计数变量。  
      1. 调用构造函数初始化对象时，将引用计数初始化为1。  
      2. 调用拷贝构造函数初始化对象时，拷贝给定对象的计数器，并将计数器+1。  
      3. 调用析构函数销毁对象时，将引用计数-1，当引用计数为0时，销毁共享资源。  
      4.调用拷贝运算符时，将右值引用计数+1，将左值引用计数-1，当左值引用计数为0时，销毁共享资源。  
  >* unique_ptr：  
  >unique_ptr独享资源，unique_ptr不可拷贝可移动。unique_ptr对象构造时获取资源，析构时释放资源。  
  >* shared_ptr：  
  >shared_ptr共享资源，shared_ptr可以拷贝。每个shared_ptr都有一个引用计数，引用计数表示shared_ptr指向的资源当前被多少个shared_ptr共享，当引用计数为0时（即：没有shared_ptr共享该资源）该资源被释放。
  >* 循环引用：  
  >```
  >class A
  >{
  >public:
  >     shared_ptr<B> _sp_b_;     
  >};
  >class B
  >{
  >public:
  >     shared_ptr<A> _sp_a_;     
  >};
  >int main()
  >{
  >     shared_ptr<A> sp_a(new A());
  >     shared_ptr<B> sp_b(new B());
  >     sp_a._sp_b_ = sp_b;
  >     sp_b._sp_a_ = sp_a;
  >}
  >```
  >当sp_a、sp_b析构时，并不会释放它们指向的资源，从而造成内存泄漏。  
  >* weak_ptr：  
  >
* nullptr
  >NULL和nullptr的定义分别如下:  
  >```
  >#define NULL 0  
  >#define nullptr ((void *)0)  
  >```
  >可以看出NULL为常量0，nullptr为空指针  
  >引入nullptr是为了避免函数重载时的二义性，如：  
  >```
  >void fun_NULL(int);
  >void fun_nullptr(int *);
  >```
