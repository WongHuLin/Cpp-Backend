### [环形链表](https://leetcode.com/problems/linked-list-cycle/)
```
class Solution
{
public:
	bool hasCycle(ListNode *head)
	{
		unordered_set<ListNode *> hash;
		while (head != nullptr)
		{
			if (hash.find(head) != hash.end())
				return true;
			hash.insert(head);
			head = head->next;
		}
		return false;
	}
};
```
```
class Solution
{
public:
	bool hasCycle(ListNode *head)
	{
		if (head == nullptr)
			return false;
		ListNode *slow = head;
		ListNode *fast = head->next;
		while (fast && fast->next)
		{
			if (slow == fast)
				return true;
			slow = slow->next;
			fast = fast->next->next;
		}
		return false;
	}
};
```
### [删除链表的倒数第N个节点](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
```
class Solution
{
public:
	ListNode *removeNthFromEnd(ListNode *head, int n)
	{
		ListNode *next = head;
		ListNode *nth_pre = head;
		int i = 0;
		while (next)
		{
			i++;
			if (i > n + 1)
				nth_pre = nth_pre->next;
			next = next->next;
		}
		if (n == 1 && i == 1)
			return nullptr;
		if (n == i)
			return head->next;
		ListNode *tmp = nth_pre->next;
		nth_pre->next = nth_pre->next->next;
		delete tmp;
		return head;
	}
};
```
### [链表求和](https://leetcode.com/problems/add-two-numbers/)
```
class Solution
{
public:
	ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)
	{
		ListNode res(0);
		ListNode *l3 = &res;
		int digit, rest = 0;
		while (l1 || l2 || rest)
		{
			digit = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + rest;
			rest = digit / 10;
			l3->next = new ListNode(digit % 10);
			l3 = l3->next;
			l1 = l1 ? l1->next : l1;
			l2 = l2 ? l2->next : l2;
		}
		return res.next;
	}
};
``` 
### [反转链表](https://leetcode.com/problems/reverse-linked-list/)
```
class Solution
{
public:
	ListNode *reverseList(ListNode *head)
	{
		ListNode *pre = nullptr;
		ListNode *cur = head;
		while (cur)
		{
			ListNode *tmp = cur->next;
			cur->next = pre;
			pre = cur;
			cur = tmp;
		}
		return pre;
	}
};
```
```
class Solution
{
public:
	ListNode *reverseList(ListNode *head)
	{
		if (!head || !head->next)
			return head;
		ListNode *tmp = reverseList(head->next);
		head->next->next = head;
		head->next = nullptr;
		return tmp;
	}
};
```
### [合并两个有序链表](https://leetcode.com/problems/merge-two-sorted-lists/)
```
class Solution
{
public:
	ListNode *mergeTwoLists(ListNode *l1, ListNode *l2)
	{
		ListNode tmp(0);
		ListNode *cur = &tmp;
		while (l1 != nullptr && l2 != nullptr)
		{
			if (l1->val < l2->val)
			{
				cur->next = l1;
				cur = l1;
				l1 = l1->next;
			} else
			{
				cur->next = l2;
				cur = l2;
				l2 = l2->next;
			}
		}
		if (l1 == nullptr)
			cur->next = l2;
		else
			cur->next = l1;
		return tmp.next;
	}
};
```
### [两数之和](https://leetcode.com/problems/two-sum/)
```
class Solution
{
public:
	vector<int> twoSum(vector<int>& nums, int target) 
	{
	    unordered_map<int,int> index;
	    for(int i = 0; i<nums.size(); i++)
	    {
        	int element = target - nums[i];
        	if(index.find(element)!=index.end())
        	{
	            return vector<int>{i,index[element]};
    	    }
        	index[nums[i]] = i;
    	}
	}
};
```
### [atoi](https://leetcode.com/problems/string-to-integer-atoi/)
```
class Solution
{
public:
	int myAtoi(string str)
	{
		int sign = 1, base = 0, i = 0;
		while (str[i] == ' ')
			i++;
		if (str[i] == '-' || str[i] == '+')
			sign = 1 - 2 * (str[i++] == '-');
		while (str[i] >= '0' && str[i] <= '9')
		{
			if (base > INT_MAX / 10 || (base == INT_MAX / 10 && str[i] - '0' > 7))
			{
				if (sign == 1)
					return INT_MAX;
				else
					return INT_MIN;
			}
			base = 10 * base + (str[i++] - '0');
		}
		return base * sign;
	}
};
```
### [数组中的第K个最大元素](https://leetcode.com/problems/kth-largest-element-in-an-array/)
```
class Solution 
{
public:
    int findKthLargest(vector<int>& nums, int k) 
	{
        int left = 0, right = nums.size() - 1;
        while (true) 
		{
            int pos = partition(nums, left, right);
            if (pos == k - 1) return nums[pos];
            else if (pos > k - 1) right = pos - 1;
            else left = pos + 1;
        }
    }
    int partition(vector<int>& nums, int left, int right) 
	{
        int pivot = nums[left], l = left + 1, r = right;
        while (l <= r) 
		{
            if (nums[l] < pivot && nums[r] > pivot) 
			{
                swap(nums[l++], nums[r--]);
            }
            if (nums[l] >= pivot) ++l;
            if (nums[r] <= pivot) --r;
        }
        swap(nums[left], nums[r]);
        return r;
    }
};
```
```
class Solution
{
public:
	int findKthLargest(vector<int> &nums, int k)
	{
		priority_queue<int, vector<int>, greater<int>> pq;
		for (int i = 0; i < k; i++)
			pq.push(nums[i]);
		for (int i = k; i < nums.size(); i++)
		{
			if (nums[i] > pq.top())
			{
				pq.pop();
				pq.push(nums[i]);
			}
		}
		return pq.top();
	}
};
```
### [搜索旋转排序数组](https://leetcode.com/problems/search-in-rotated-sorted-array/)
```
class Solution
{
public:
	int search(vector<int> &nums, int target)
	{
		int start = 0, end = nums.size() - 1;
		while (start <= end)
		{
			int mid = (end + start) / 2;
			if (nums[mid] == target)
				return mid;
			if (nums[start] <= nums[mid])
			{
				int res = binary_search(nums, start, mid, target);
				if (res == -1)
					start = mid + 1;
				else
					return res;
			} else
			{
				int res = binary_search(nums, mid + 1, end, target);
				if (res == -1)
					end = mid - 1;
				else
					return res;
			}
		}
		return -1;
	}

	int binary_search(vector<int> &nums, int start, int end, int target)
	{
		while (start <= end)
		{
			int mid = (start + end) / 2;
			if (nums[mid] == target)
				return mid;
			if (nums[mid] < target)
				start = mid + 1;
			if (nums[mid] > target)
				end = mid - 1;
		}
		return -1;
	}
};
```  
### [逆序对](https://www.lintcode.com/problem/reverse-pairs/description)  
```
class Solution
{
public:
	long long reversePairs(vector<int> &A)
	{
		if (!A.size())
			return 0;
		long long counter = 0;
		vector<int> tmp(A);
		merge(A, tmp, 0, A.size() - 1, counter);
		return counter;
	}

	void merge(vector<int> &A, vector<int> &tmp, size_t l, size_t r, long long &counter)
	{
		if (l >= r) return;
		size_t mid = (r - l + 1) / 2 + l;
		merge(A, tmp, l, mid - 1, counter);
		merge(A, tmp, mid, r, counter);
		size_t i = l, l1 = l, l2 = mid;
		while (l1 <= mid - 1 && l2 <= r)
		{
			if (tmp[l1] <= tmp[l2])
			{
				A[i++] = tmp[l1++];
			} else
			{
				A[i++] = tmp[l2++];
				counter += mid - l1;
			}
		}
		while (l1 <= mid - 1)
			A[i++] = tmp[l1++];
		while (l2 <= r)
			A[i++] = tmp[l2++];
		tmp = A;
	}
};
```
### [二叉搜索树中第K小的元素](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)  
```
class Solution 
{
public:
    int counter = 0;
    int res = 0;
    int kthSmallest(TreeNode* root, int k) 
    {
        if(root == nullptr)
            return 0;
        kthSmallest(root->left,k);
        counter++;
        if(counter==k)
            res = root->val;
        kthSmallest(root->right,k);
        return res;
    }
};
```
### [二叉树中的最大路径和](https://leetcode.com/problems/binary-tree-maximum-path-sum/)
```
class Solution 
{
public:
    int res = INT_MIN;
    int maxPathSum(TreeNode* root) 
    {
        fun(root);
        return res;
    }
    int fun(TreeNode* root)
    {
        if(!root)
            return 0;
        int left = max(0,fun(root->left));
        int right = max(0,fun(root->right));
        res = max(res, root->val + left + right); 
        return max(left,right)+root->val;
    }
};
```
二叉树最远两节点  
K路归并  
智力题：赛马  
>有 25 匹马和 5 条赛道，赛马过程无法进行计时，只能知道相对快慢。问最少需要几场赛马可以知道前 3 名。  
>>先把 25 匹马分成 5 组，进行 5 场赛马，得到每组的排名。再将每组的第 1 名选出，进行 1 场赛马，按照这场的排名将 5 组先后标为 A、B、C、D、E。可以知道，A 组的第 1 名就是所有 25 匹马的第 1 名。而第 2、3 名只可能在 A 组的 2、3 名，B 组的第 1、2 名，和 C 组的第 1 名，总共 5 匹马，让这 5 匹马再进行 1 场赛马，前两名就是第 2、3 名。所以总共是 5+1+1=7 场赛马。  
>>A 组：1，2，3，4，5  
>>B 组：1，2，3，4，5  
>>C 组：1，2，3，4，5  
>>D 组：1，2，3，4，5  
>>E 组：1，2，3，4，5  

智力题：扔鸡蛋  
>一栋楼有 100 层，在第 N 层或者更高扔鸡蛋会破，而第 N 层往下则不会。给 2 个鸡蛋，求 N，要求最差的情况下扔鸡蛋的次数最少。  
>>
智力题：对一批编号为1-100，全部开关朝上（开）的灯进行以下***作：凡是1的倍数反方向拨一次开关；2的倍数反方向又拨一次开关；3的倍数反方向又拨一次开关……问：最后为关熄状态的灯的编号是哪些？  