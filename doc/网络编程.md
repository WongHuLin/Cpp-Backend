### socket流程
* 客户端
  ```
  char *ip_addr;
  int sockfd;
  sockaddr_in server_addr{};
  bzero(&server_addr, sizeof(server_addr));

  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(PORT_NUM);
  inet_pton(AF_INET, ip_addr, &server_addr.sin_addr);

  sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  connect(sockfd, (struct sockaddr *) &server_addr, sizeof(server_addr));

  close(sockfd);
  ```
* 服务器端
  ```
  int listenfd;
  int connfd;
  const int PORT_NUM = 23333;
  const int LISTEN_QUEUE_SIZE = 50;
  sockaddr_in sever_addr{};
  sockaddr_in peer_addr{};
  socklen_t peer_len{};

  sever_addr.sin_family = AF_INET;
  sever_addr.sin_port = htons(PORT_NUM);
  sever_addr.sin_addr.s_addr = INADDR_ANY;

  listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  bind(listenfd, (sockaddr *) &sever_addr, sizeof(sever_addr));
  listen(listenfd, LISTEN_QUEUE_SIZE);
  connfd = accept(listenfd, (sockaddr *) &peer_addr, &peer_len);

  close(connfd);
  close(listenfd);
  ```
### I/O模型
>![IO_model](../pic/IO_model.png "IO_model")  
>
### select
>`int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);`  
>以I/O复用的方式监听多个文件描述符,调用前先在3个相关事件的fd_set中注册文件描述符,select返回时会在三个fd_set中存储相关事件就绪的文件描述符。失败时返回-1,超时返回0,成功时返回所有就绪的文件描述符的个数。  
>* nfds为所有select正在监听的文件描述符的最大值
>* readfds存储希望被监听read操作的文件描述符
>* writefds存储希望被监听write操作的文件描述符
>* exceptfds存储希望被监听意外情况(如带外数据)的文件描述符
>* timeout用来指定select的超时时间
>```
>struct timeval {
>    time_t      tv_sec;     /* Seconds */
>    suseconds_t tv_usec;    /* Microseconds (long int) */
>};
>```
>fd_set最大支持FD_SETSIZE个文件描述符,linux下FD_SETSIZE为1024,对fd_set的操作有以下四种:  
>`void FD_ZERO(fd_set *fdset);`  
>将fdset清空  
>`void FD_SET(int fd, fd_set *fdset);`  
>将fd加入到fdset中  
>`void FD_CLR(int fd, fd_set *fdset);`  
>将fd从fdset中删除  
>`int FD_ISSET(int fd, fd_set *fdset);`  
>如果fdset存在fd返回1,否则返回0


### poll
>`int poll(struct pollfd *fds, nfds_t nfds, int timeout);`  
>```
>struct pollfd {
>    int fd;            /* File descriptor */
>    short events;      /* Requested events bit mask */
>    short revents;     /* Returned events bit mask */
>};
>```
### epoll 
`int epoll_create(int size);`  
` int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);` 
` int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);`  
>* 边缘触发
>* 水平触发
### Reactor与Proactor
### [Kiwi](https://github.com/Xing-YuKai/Kiwi)