# 内存管理
>## 虚拟内存（Virtual Memory）
>操作系统为每个进程虚拟化出独立的逻辑地址空间，这个空间大小与操作系统位数有关（如：2^32bytes或2^64bytes）
>* 页表（Page Table）  
>操作系统将物理内存划分为多个页框（Page Frame）每个页框有自己的页框号（Page Frame Number）页框内为一片连续存储的内存。    
>操作系统将每个进程的虚拟内存地址划分为两部分：高位为虚拟页表号（VPN）低位为在虚拟页表中的偏移（Offset）  
>每个进程都有自己的页表（Page Table），页表由页表入口（Page Table Entry）组成，PTE不仅包含VPN与PFN的对应关系，还有一些功能位分别表示这个页是否时可读的（protection bit）、是否是有效的（valid bit）、是否被更改过（dirty bit）、对应的数据是在硬盘还是在内存中（present bit） 等等。  
>当进程用虚拟内存地址访问内存时，硬件中的内存管理单元（MMU）将VPN翻译为PFN,offset不变。由于虚拟内存并不完全对应物理内存，一部分虚拟内存可能对应在磁盘空间上。当访问的虚拟内存地址不再物理内存上时，将发生缺页中断，此时会将数据从硬盘加载到物理内存当中。
>* 快表(Translation-Lookaside-Buffer)  
>如果每次访问内存都需要MMU将虚拟内存转化为物理内存，会一定程度上影响效率。所以引入TLB这个概念，TLB是MMU的一部分，功能可以理解为内存地址翻译的cache。每当MMU进行地址翻译的时候先查找TLB中是否有VPN-PFN对应关系，如果TLB中没有这个对应关系再去页表中查找对应关系并对TLB进行替换。
>* 多级页表  
>如果每个页框中包含的内存较多，那么就更容易造成内存碎片。如果包含的内存较小，那么就需要更多的VPN-PFN对应关系也就需要更大的页表。我们假设在一个32位系统中，每个页的大小为4KB，则offset为12位VPN为20位，每个PTE为4字节，那么每个进程便需要4MB大小的页表，如果系统运行100个进程，那么仅仅为了内存翻译就需要400MB！  
>多级页表可以说是由增加时间复杂度降低空间复杂度的思想而来。简单来说我们将VPN进行划分，高位VPN对应高级页表，地位VPN对应低级页表，高级页表中包含低级页表位置的对应关系，最低级的页表包含PFN的对应关系。
>* 替换算法
>   * FIFO（First In First Out）：  
>   页被存放在队列当中，每次加入新页都将其置于队头，当需要替换时将队尾的页淘汰掉（即最先进入的页）。
>   * LRU（Least Recently Used）：  
>   页被存放在链表中，每次加入新页都将其置于链头，每当页命中时将命中页插入链头，当需要替换时将链尾的页淘汰掉（即最近一段时间访问次数最少的页）。  
>   * LFU（Least Frequently Used）：  
>   记录每个页的命中次数，当需要替换时将命中次数最少的页淘汰掉（即访问次数最少的页）。  
>   * Clock算法：  
>   页被存放在环形链表中，链表中有一个指针指向页，每当页命中时将页的引用位（reference bit）置为1（默认为0），当需要替换时如果指针指向的页引用位为0将此页替换并将指针前移，如果指向的页引用位为1便将引用位设为0并前移指针。
>##  内存段（Segmentation）
>内存段也是一种管理内存的方式，但目前主流操作系统已经不用其管理内存。一般来说进程会用这种方式管理自己的堆内存（动态分配内存区）
# 进程与线程
>## 进程
>## 线程
# 并发
# 进程间通信
# 文件系统