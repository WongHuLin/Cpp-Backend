### 大端法与小端法
* 大端法  
最高有效字节在最前面的方式称为大端法（网络字节序为大端法），例如假设变量x类型为int型，位于地址0x100的地方，其16进制值为0x12345678  
12  34	56	78  
* 小端法  
最低有效字节在最前面的方式称为小端法：  
78	56	34	12
* 判断大端法小端法
```
union 
{
    short  s;
    char   c[sizeof(short)];
} un;
un.s = 0x0102;
if (un.c[0] == 1 && un.c[1] == 2)
    printf("大端法\n");
else if (un.c[0] == 2 && un.c[1] == 1)
    printf("小端法\n");
```
* 转换大小端
```
uint32_t reversebytes_uint32t(uint32_t value)
{
    return (value & 0x000000FFU) << 24 | (value & 0x0000FF00U) << 8 | (value & 0x00FF0000U) >> 8 | (value & 0xFF000000U) >> 24; 
}
``` 
* 库  
   * 静态库  
   使用`add_library(library_name STATIC ${source_code})`生成.a文件  
   使用`link_libraries(${library_path})`链接静态库  
   静态库每次更新都需要重新编译可执行文件。如果由多个程序使用同一个静态库，那么每个程序的内存中都需要有一份静态库的拷贝，浪费了内存空间。  
   * 动态库  
   使用`add_library(library_name SHARED ${source_code})`生成.so文件  
   使用`link_libraries(${library_path})`链接动态库  
   动态库每次更新只需要发布.so文件。如果由多个程序使用同一个动态库，内存中只需要有一份动态库的拷贝。但是如果库的更新与程序出现了冲突，那么需要在运行期才会报错，而静态库可以在编译器就会报错。  

malloc:https://blog.csdn.net/mithebut/article/details/48371487  
vector扩容:https://blog.csdn.net/dengheCSDN/article/details/78985684  
虚函数的执行过程:https://blog.csdn.net/imred/article/details/80717756 
超时Socket:UNP14.2 