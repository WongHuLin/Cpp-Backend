>OSI七层模型：  
>* 应用层(Application layer)  
> 进行数据的发送与接受与数据的处理。
>* 表示层(Presentation layer)  
> 对将要发送的数据进行编码和对接收的数据进行解码。
>* 会话层(Session layer)  
> 建立、管理、终止应用程序之间的连接。
>* 传输层(Transport layer)  
> 对将要发送的数据进行分块、打包和对接受的数据进行合并处理。
>* 网络层(Network layer)  
> 对待传输的数据进行选路和推送。
>* 链路层(Link layer)  
> 将数据包转换为比特流从而提供给物理层和将物理层的比特流转换为数据包。
>* 物理层(Physical layer)  
> 比特流的物理载体。
> >以工厂A要向商户B寄送一批家具为例子：  
> >* 应用层：  
> >寄送家具这项服务所位于的位置即在应用层，它只负责寄送家具到指定的地点，不关注这批家具的用途。
> >* 表示层：  
> >表示层的功能类似于将家具拆分成易于能够进行运输的零部件，以及将接收到的零部件组装成家具。  
> >* 会话层：  
> >会话层的功能类似于记录这次寄送家具的服务何时开始何时结束。
> >* 传输层：  
> >传输层的功能类似于将这批零部件打包成多个包裹分批次的寄出，以及将接收到的包裹拆包并派送到指定的地点。 
> >* 网络层：  
> >网络层的功能类似于选定运输包裹的路线。
> >* 链路层：  
> >链路层的功能类似于将包裹进行装卸使得运输工具可以装载。例如用轮船作为运输工具就需要将包裹装入集装箱。  
> >* 物理层：  
> >物理层类似于运输包裹的运输工具。例如轮船、卡车、飞机。  
# 网络层 
# 传输层
* UDP与TCP的区别  
  >UDP是一种简单的面向数据包的传输层协议，只简单的中转应用层与网络层的数据。使用UDP传输数据可能会导致数据丢失，数据乱序等问题。TCP的出现得以解决这些问题，TCP相当于在UDP的基础上作加法。TCP保证数据按序到达，TCP是面向连接的，TCP具有数据重传等功能。一般情况下程序都会使用TCP作为传输层协议，只有当程序对TCP提供的功能没有需求或对UDP的高性能有需求的情况下使用UDP作为传输层协议。
* TCP报头  
  >* 目标端口（16bits）与源端口（16bits）：  
  用来识别发送和接收应用程序。  
  >* 序列号（32bits）：  
  用来识别数据传输字节流中的字节。当连接建立时，主机将设置一个初始序列号（ISN），之后每次发送数据，序列号 = ISN + 数据在字节流中的偏移。例如：ISN为1024，第一段数据为512，则第二段数据的序列号为1024 + 512。  
  >* 确认号（32bits）：  
  用来表示下一次收到的数据的序列号，确认号 = 上次收到的序列号 + 1。  
  >* 报头长度（4bits）：  
  用来表示TCP报头的长度 = 报头长度 * 4字节，则TCP报头最长为15 * 4 = 60字节。  
  >* 保留位（6bits）：  
  TCP报头中的保留位一般设置为0，用以未来增加功能，个人猜测是用来填充为32bits的整数倍。  
  >* 标志位（6bits）：  
  标志位的六个bits分别代表六个标志位，从低到高依次为：  
      1. URG：  
      URG位为1时，表示紧急指针位有效。  
      2. ACK：  
      ACK位为1时，表示确认号有效。  
      3. PSH：  
      接收方需要尽快的将数据传送到应用程序。  
      4. RST：  
      重置连接。  
      5. SYN：   
      同步序列号从而建立连接。  
      6. FIN： 
      发送方完成数据的发送。  
  >* 窗口大小（16bits）：   
  用来表示窗口大小，窗口用来实现TCP的流量控制功能。  
  >* 校验和（16bits）：  
  用来校验TCP报头与TCP数据的正确性。由发送方计算，接收方验证。  
  >* 紧急指针（16bits）：  
  紧急指针为一个正向偏移量，与序列号相加得到紧急数据的最后一个字节的序列号。
  >* TCP选项位
* UDP报头  
  >* 目标端口（16bits）与源端口（16bits）：  
  用来识别发送和接收应用程序。  
  >* UDP长度（16bits）：  
  用来表示UDP报头加上UDP数据的长度 = UDP长度 * 1字节。  
  >* 校验和（16bits）：  
  用来校验UDP报头与UDP数据的正确性。由发送方计算，接收方验证。   
* TCP三次握手  
   >1. 客户端发送一个SYN位为1的段，指出客户端的初始序列号（ISN）。
   >2. 服务端回应一个ACK、SYN位为1的段，指出服务端的初始序列号（ISN）并确认客户端的SYN段。
   >3. 客户端回应一个ACK位为1的段，确认服务端的SYN段。
* TCP四次挥手  
  >1. 客户端发送一个FIN位为1的段，表明客户端向服务端的数据传输已经终止。
  >2. 服务端回应一个ACK位为1的段，确认客户端的FIN段。
  >3. 服务端发送一个FIN位为1的段，表明服务端向客户端的数据传输已经终止。
  >4. 客户端回应一个ACK位为1的段，确认服务端的FIN段。
* 三次握手四次挥手的原因  
  >三次握手：连接的成功建立需要使客户端知道服务端能够接收和发送数据，服务端知道客户端能够接受和发送数据。第一次握手使得服务端知道客户端能够发送数据，第二次握手使得客户端知道服务端能够发送和接收数据，第三次握手使得服务端知道客户端能够接受数据。  
  >四次挥手：TCP为全双工通信，要想完全断开连接，需要断开服务端到客户端的数据传输，以及客户端到服务端的数据传输。第二次与第三次挥手有时可以合并。
* TCP半关闭
  >由于TCP是全双工通信，所以我们可以只断开一个方向的数据传输而保持相反方向的数据传输。
* TCP连接状态  
  >![连接状态](../pic/TCP_state_transition.png "连接状态")  
  >* CLOSED：  
  初始状态，表示TCP连接是“关闭着的”或“未打开的”。  
  >* LISTEN：  
  表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。  
  >* SYN_SEND：  
  客户端主动连接，发送SYN段，进入此状态。  
  >* SYN_RECV：  
  服务端被动连接，收到SYN段并发送服务端SYN段，进入此状态。  
  >* ESTABLISH：  
  表示连接建立。客户端发送了最后一个ACK段后进入此状态，服务端接收到ACK段后进入此状态。  
  >* FIN_WAIT_1：  
  主动终止连接的一方发送了FIN段后进入。等待对方的FIN段。  
  >* CLOSE_WAIT：  
  被动终止连接的一方接收到FIN段之后等待关闭的阶段。在接收到对方的FIN段之后回复ACK段的，表示已经知道对方关闭数据传输。但是本方是否关闭数据传输取决于是否还有数据需要发送给对方，在本方发送FIN段之前均为此状态。  
  >* FIN_WAIT_2：  
  主动终止连接的一方收到对方的ACK段，此时为半关闭状态，本方已经关闭数据传输，等待对方关闭。但并没有立即接收到对方的FIN段，进入此状态。  
  >* LAST_ACK：  
  被动终止连接的一方发送FIN段，等待最后的ACK响应，进入此状态。  
  >* TIME_WAIT：  
  主动断开连接方发送完最后一个ACK段时进入此状态而不是进入CLOSED状态。一是为了使一旦最后一个ACK段丢失后对方重发FIN段后主动断开连接方依然可以回复ACK段。二是如果不进入TIME_WAIT状态主动断开连接方以和旧连接相同的四元组建立新的连接，而此时旧连接滞留在网络中的数据段到达新连接从而造成序列号不匹配的问题。TIME_WAIT一般维持2MSL的时间。
* TCP超时重传
  >* RTT：  
  RTT（Round Trip Time）为发送数据到接收到确认之间的时间间隔，即数据在网络中的往返时间。TCP可以用Timestamp选项计算每个被确认的TCP段的RTT。  
  >* RTO：  
  RTO（Retransmission Time Out）当发送数据后经过了RTO时间还未收到确认将重传数据。RTO由系统根据RTT进行计算，计算RTO的值应当尽可能的预测网络状况考虑网络波动。RTO的值由平滑RTT与平滑RTT平均偏差有关，平滑的意思是新值的一部分由就值决定。    
  >* Karn算法：  
  Karn算法大意为：当发送的数据段超时重传后，就不使用该数据段的RTT作为样本计算RTO。因为当数据段重传后收到的确认段可能是对之前超时数据段的确认，也可能是对重传数据段的确认，所以这个数据段的RTT不具有参考价值。  
  但这又引出另外的问题，比如当网络延时突然增大，此时数据段会进行重传，但由于Karn算法，此次RTT不作参考，这样会导致RTO无法更新。所以对Karn算法进行修正：每次发生重传都将RTO增大，一般为将RTO置为原RTO的两倍，当不发生重传后再正常计算RTO。   
* 延时ACK  
  >当接收方收到发送方的数据时不会立即回复ACK段，而是等待一定时间（最大一般为200ms）如果接收方此时有数据要发送那么就可以在发送的数据段内捎带上ACK信息，或者又接收到了放送方的数据那么就可以合并两个ACK信息。捎带ACK相比直接发送ACK段要节省40字节的TCP报头与IP报头，所以延时ACK可以提高网络吞吐量。 
* Nagle算法  
  >Nagle算法大意为：当TCP连接中有未被确认的数据段时，小于MSS大小的数据段将被放置于等待队列，直到收到确认段。  
  >优点：通过减少数据包的发送量，从而提高网络吞吐量。因为每次发送数据都会加上40字节的TCP报头和IP报头，若数据本身较小则效率比较低。  
  >缺点：会降低实时性，典型的例子为：当发送方不断的进行小数据段的“写写读”操作时，由于Nagle算法与延时ACK此时会大幅增加延时。如果非常重视实时性，可以使用TCP_NODELAY选项关闭Nagle算法。  
* TCP流量控制  
  >原因：TCP会在操作系统内核中为每个连接维护一个接收缓冲区，当收到正确的数据时会将数据存储在缓冲区中，等待进程读取数据。但是当接受方读取数据的速度较慢，而发送方发送数据的速度较快，那么就会造成缓冲区溢出，此时发送方再发送的数据会被接收方丢弃。为了避免这样的问题，TCP提供流量控制机制，避免缓冲区溢出。  
  >机制：TCP使用滑动窗口进行流量控制。在建立TCP连接时双方会在TCP报头中指出自己的窗口大小。接收方接受到数据但进程并未从缓冲区读取数据时，接收方减少相应字节的窗口大小（即窗口左边缘右移），并在ACK段中告诉发送方减少后的窗口大小。当接受方的进程从缓冲区读取一部分数据后，接收方增大窗口大小（即窗口右边缘右移），并在ACK段中告诉发送方增大后的窗口大小。当发送方发现接收方的窗口大小为0时，便停止数据的发送，直到窗口大小增大。接收方也可以减少自己的最大窗口大小（即窗口右边缘左移）但RFC强烈不建议这样做！
  >>糊涂窗口综合症：如果接收方只通知一个小窗口，那么发送方就只能按照这个窗口大小发送少量的数据，如果发送的数据过小那么TCP传输效率就会变低。TCP用以下措施避免这种情况的发生：接收方只在窗口大小为一个MSS或最大窗口大小一半时再进行通知；对于发送方，除了考虑对方窗口大小（一个MSS或最大窗口大小的一半）外，当发送方没有未被确认的数据段或者Nagle算法关闭时也会直接发送数据段。
* TCP拥塞控制
  >什么是网络拥塞？在网络中有很多的路由器，路由器也有自己的接收缓冲区。当数据包到达时，被存储在缓冲区中等待路由器处理。当路由器接受到的数据包太多，此时就会发生拥塞。新到达的数据包在缓冲区中等待会消耗大量的时间，这也是网络延迟增加的主要原因。如果路由器的接受速度超过处理数据的速度，此时新到达的数据包会被丢弃，造成大量的丢包。  
  >TCP的拥塞控制分为两部分  
  >>* 慢开始&拥塞避免：  
  >>  发送方维护一个拥塞窗口变量（cwnd）与慢开始门限（ssthresh），cwnd默认为1数据段、sstresh默认为16数据段。  
  >>  慢开始阶段（cwnd < ssthresh）：发送方每次发送不超过cwnd个数据段，当所有发送的数据段都被确认后将cwnd翻倍。  
  >>  拥塞避免阶段（cwnd > ssthresh）：此时当所有发送的数据都被确认后仅将cwnd+1，一旦发生拥塞（超时或收到重复ACK段）sstresh = max ( 2 , cwnd / 2 )，当发生超时的时候cwnd = 1，当接收到3个重复ACK段时cwnd = sstresh / 2 + 3。  
  >>* 快重传&快恢复：  
  >> 快重传：当接收方接收到一个乱序数据段时，立即发送一个重复ACK段也就是上一次发送的ACK段，此ACK段不会被延时发送。当发送方接收到一个重复ACK段时，接收方并不确定这是因为丢包还是序列号乱序导致的，但一旦接收方连续收到3个重复ACK段时，可以大概率确定发生了丢包，此时不用等待重传计时器超时，立即对丢失的数据段进行重传。  
  >> 快恢复：当接收方收到3个重复ACK段时，此时的拥塞没有发生超时的时候严重，便不用再进行慢开始（即cwnd = 1），而是将sstresh = max ( 2 , cwnd / 2 );cwnd = sstresh / 2 + 3。加3是因为，既然已经收到3个重复ACK段这就表明已经有3个数据段被对方接受并丢弃，但这3个数据段因为没有被确认依旧占用这拥塞窗口的大小，所以将拥塞窗口加3进行补偿。 
* 拥塞控制与流量控制
  >* 本质上两者都是对流量进行限制，只不过前者限制的是发送数据的流量，后者限制的是接收数据的流量。
  >* 流量控制主要由双方的接收缓冲区大小决定，而拥塞控制则由网络状况决定。
  >* 最终的限制大小为两者共同作用下的结果。
* TCP定时器
  >* 连接建立定时器：  
  在建立连接发送SYN段后TCP启动一个定时器，当定时器超时后重传SYN段并启动一个新的定时器将时间增加，一定次数的重传后将终止连接。
  >* 重传定时器：  
  TCP在发送数据段之后启动一个重传定时器，当定时器超时后重传数据段并启动一个新的定时器将时间增加，一定次数的重传后将终止连接。
  >* 延时ACK定时器：  
  在收到数据段时TCP启动一个延时ACK定时器，若定时器超时后ACK段依然没有被捎待发送便独立发送ACK段。  
  >* 坚持定时器：  
  当接受方的窗口关闭后一旦窗口打开，那么接收方会单独发送一个ACK段通知发送方窗口已经打开。然而一旦此ACK段丢失，发送方会等待对方窗口打开的通知，接收方会等待对方的数据，此时就会陷入死锁。  
  为了避免这种情况的发生，当发送方被通知对方的窗口已经关闭，便会启动一个坚持定时器。当定时器超时后发送方会向对方发送一个探测报文（一个只含一字节数据的数据段）探测对方的窗口是否仍未打开。如果已经打开就关闭此定时器，如果仍未打开就启动一个新的定时器将时间增加。坚持定时器会一直存在直到对方发送窗口打开的通知或连接关闭。  
  >* 保活定时器：  
  用来检测对方是否还能收到数据。当用户开启了SO_KEEPLIVE选项后，TCP启动一个保活定时器，每当双方发生数据交互时保活定时器重置，当定时器超时后向对方发送探测报文，一定时间后对方如果没有回复就再发一个，一定次数后TCP认为对方已经失去响应，便关闭此连接。
  >* FIN_WAIT_2定时器：  
  当一方主动关闭连接（非半关闭）并收到第一个ACK进入FIN_WAIT_2状态后，TCP启动一个FIN_WAIT_2定时器，如果定时器超时后依然没有收到对方的FIN段，主动关闭连接的一方将直接进入CLOSED状态放弃此连接。
  >* TIME_WAIT定时器：  
  当主动断开连接方进入TIME_WAIT状态后TCP便启动一个TIME_WAIT定时器，定时器超时前如果再次收到对方的FIN段就重置此定时器，定时器超时后便离开TIME_WAIT状态。 
* TCP可靠传输  
  >* 建立连接：  
  在通信前建立连接，确保通信双方可以向对方放送数据和接收对方的数据。
  >* 序列号：  
  确保数据是按序到达的。
  >* 确认号：  
  确保数据完整到达与确保对方收到数据。  
  >* 数据校验：  
  确保数据的正确。  
  >* 超时重传：  
  确保未能到达的数据段被重新发送。  
  >* 窗口机制：  
  对发送与接收的流量设置一定的瓶颈。
# 应用层
